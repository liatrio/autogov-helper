package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/go-github/v60/github"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	owner       = "liatrio"
	repo        = "demo-gh-autogov-policy-library"
	schemasPath = "schemas/"
)

var targetDir = filepath.Join("..", "generated") // generate in schema package's generated dir

// commonStructs defines the shared types used across schemas
const commonStructs = `// Code generated by generate.go. DO NOT EDIT.

package schema

// Subject represents a subject in an attestation
type Subject struct {
	Name   string ` + "`json:\"name\"`" + `
	Digest struct {
		SHA256 string ` + "`json:\"sha256\"`" + `
	} ` + "`json:\"digest\"`" + `
}

// SubjectItem represents a subject item in an attestation
type SubjectItem struct {
	Name   string ` + "`json:\"name\"`" + `
	Digest struct {
		SHA256 string ` + "`json:\"sha256\"`" + `
	} ` + "`json:\"digest\"`" + `
}

// Statement represents the base statement type for all attestations
type Statement struct {
	Type          string    ` + "`json:\"_type\"`" + `
	PredicateType string    ` + "`json:\"predicateType\"`" + `
	Subject       []Subject ` + "`json:\"subject\"`" + `
}

// Inputs represents workflow inputs
type Inputs map[string]any
`

// requiredFields defines the required fields for each schema type
var requiredFields = map[string][]string{
	"metadata": {
		"_type",
		"predicateType",
		"subject",
		"predicate.artifact.version",
		"predicate.artifact.created",
		"predicate.artifact.type",
		"predicate.repositoryData.repository",
		"predicate.repositoryData.repositoryId",
		"predicate.repositoryData.githubServerURL",
		"predicate.ownerData.owner",
		"predicate.ownerData.ownerId",
		"predicate.runnerData.os",
		"predicate.runnerData.arch",
		"predicate.runnerData.environment",
		"predicate.workflowData.workflowRefPath",
		"predicate.workflowData.inputs",
		"predicate.workflowData.branch",
		"predicate.workflowData.event",
		"predicate.jobData.runNumber",
		"predicate.jobData.runId",
		"predicate.jobData.status",
		"predicate.jobData.triggeredBy",
		"predicate.jobData.startedAt",
		"predicate.jobData.completedAt",
		"predicate.commitData.sha",
		"predicate.commitData.timestamp",
		"predicate.organization.name",
		"predicate.compliance.policyRef",
		"predicate.compliance.controlIds",
		"predicate.security.permissions",
	},
	"depscan": {
		"_type",
		"predicateType",
		"subject",
		"predicate.scanner.uri",
		"predicate.scanner.version",
		"predicate.scanner.db.name",
		"predicate.scanner.db.version",
		"predicate.scanner.db.lastUpdated",
		"predicate.scanner.result",
	},
}

// specialFieldNames maps JSON field names to their Go field names
var specialFieldNames = map[string]string{
	"github_url":        "GitHubURL",
	"predicate_type":    "PredicateType",
	"owner_data":        "OwnerData",
	"runner_data":       "RunnerData",
	"commit_data":       "CommitData",
	"repository_data":   "RepositoryData",
	"workflow_data":     "WorkflowData",
	"job_data":          "JobData",
	"policy_ref":        "PolicyRef",
	"control_ids":       "ControlIDs",
	"github_server_url": "GitHubServerURL",
	"workflow_ref_path": "WorkflowRefPath",
	"run_number":        "RunNumber",
	"triggered_by":      "TriggeredBy",
	"started_at":        "StartedAt",
	"completed_at":      "CompletedAt",
	"owner_id":          "OwnerID",
	"repository_id":     "RepositoryID",
	"run_id":            "RunID",
	"id_token":          "IDToken",
	"os":                "OS",
	"sha":               "SHA",
	"github":            "GitHub",
	"url":               "URL",
	"id":                "ID",
	"ids":               "IDs",
	"_type":             "Type",
}

// title is a case transformer for strings
var title = cases.Title(language.English)

// validateSchema checks if a schema has all required fields
func validateSchema(schema map[string]interface{}) error {
	// check for required fields
	if _, ok := schema["type"]; !ok {
		return fmt.Errorf("schema has no type field")
	}

	// check for properties or definitions
	if props, ok := schema["properties"].(map[string]interface{}); ok {
		if len(props) == 0 {
			return fmt.Errorf("schema has no properties")
		}

		// check for required fields
		requiredFields := []string{"_type", "subject"}
		for _, field := range requiredFields {
			if _, ok := props[field]; !ok {
				return fmt.Errorf("missing required field: %s", field)
			}
		}

		// check that required fields are marked as required in the schema
		required, ok := schema["required"].([]interface{})
		if !ok {
			// if no required fields are specified, assume all fields are optional
			return nil
		}

		requiredMap := make(map[string]bool)
		for _, field := range required {
			if str, ok := field.(string); ok {
				requiredMap[str] = true
			}
		}
		for _, field := range requiredFields {
			if !requiredMap[field] {
				return fmt.Errorf("field %s must be marked as required", field)
			}
		}
	} else if defs, ok := schema["definitions"].(map[string]interface{}); ok {
		if len(defs) == 0 {
			return fmt.Errorf("schema has no definitions")
		}
	} else {
		return fmt.Errorf("schema has no properties or definitions")
	}

	return nil
}

// sanitizeFieldName converts a JSON field name to a Go field name
func sanitizeFieldName(name string) string {
	// check for special field names first
	if specialName, ok := specialFieldNames[name]; ok {
		return specialName
	}

	// handle hyphenated names
	if strings.Contains(name, "-") {
		name = strings.ReplaceAll(name, "-", "_")
	}

	// handle camelCase input
	if !strings.Contains(name, "_") {
		// if first character is lowercase, make it uppercase
		if len(name) > 0 && strings.ToLower(name[:1]) == name[:1] {
			return strings.ToUpper(name[:1]) + name[1:]
		}
		return name
	}

	// split by underscore and capitalize each word
	words := strings.Split(name, "_")
	for i, word := range words {
		if word == "" {
			continue
		}
		// capitalize first letter, keep rest as is
		words[i] = strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
	}
	return strings.Join(words, "")
}

// generateSchema generates a complete Go schema file
func generateSchema(schema map[string]interface{}, typeName string) (string, error) {
	var goCode strings.Builder

	// write package and imports
	goCode.WriteString("// Code generated by generate.go. DO NOT EDIT.\n\n")
	goCode.WriteString("package schema\n\n")

	// generate main type first
	goCode.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
	goCode.WriteString("\tType          string    `json:\"_type\"`\n")
	goCode.WriteString("\tPredicateType string    `json:\"predicateType\"`\n")
	goCode.WriteString("\tSubject       []Subject `json:\"subject\"`\n")
	goCode.WriteString(fmt.Sprintf("\tPredicate     %sPredicate `json:\"predicate\"`\n", typeName))
	goCode.WriteString("}\n\n")

	// generate nested types
	if props, ok := schema["properties"].(map[string]interface{}); ok {
		if predicate, ok := props["predicate"].(map[string]interface{}); ok {
			if predicateProps, ok := predicate["properties"].(map[string]interface{}); ok {
				for propName, propSchema := range predicateProps {
					if propMap, ok := propSchema.(map[string]interface{}); ok {
						if propMap["type"] == "object" {
							nestedTypeName := title.String(propName)
							if nestedProps, ok := propMap["properties"].(map[string]interface{}); ok {
								// Special handling for Artifact type
								if propName == "artifact" {
									goCode.WriteString("type Artifact struct {\n")
									goCode.WriteString("\tVersion  string `json:\"version\"`\n")
									goCode.WriteString("\tCreated  string `json:\"created\"`\n")
									goCode.WriteString("\tType     string `json:\"type\"`\n")
									goCode.WriteString("\tRegistry string `json:\"registry,omitempty\"`\n")
									goCode.WriteString("\tFullName string `json:\"fullName,omitempty\"`\n")
									goCode.WriteString("\tDigest   string `json:\"digest,omitempty\"`\n")
									goCode.WriteString("\tPath     string `json:\"path,omitempty\"`\n")
									goCode.WriteString("}\n\n")
									continue
								}

								// Special handling for Scanner type
								if propName == "scanner" {
									goCode.WriteString("type Scanner struct {\n")
									goCode.WriteString("\tURI     string `json:\"uri\"`\n")
									goCode.WriteString("\tVersion string `json:\"version\"`\n")
									goCode.WriteString("\tDb      struct {\n")
									goCode.WriteString("\t\tName        string `json:\"name\"`\n")
									goCode.WriteString("\t\tVersion     string `json:\"version\"`\n")
									goCode.WriteString("\t\tLastupdated string `json:\"lastUpdated\"`\n")
									goCode.WriteString("\t} `json:\"db\"`\n")
									goCode.WriteString("\tResult []struct {\n")
									goCode.WriteString("\t\tID       string `json:\"id\"`\n")
									goCode.WriteString("\t\tSeverity struct {\n")
									goCode.WriteString("\t\t\tMethod string `json:\"method\"`\n")
									goCode.WriteString("\t\t\tScore  string `json:\"score\"`\n")
									goCode.WriteString("\t\t} `json:\"severity\"`\n")
									goCode.WriteString("\t} `json:\"result\"`\n")
									goCode.WriteString("}\n\n")
									continue
								}

								// generate nested types recursively
								for subPropName, subPropSchema := range nestedProps {
									if subPropMap, ok := subPropSchema.(map[string]interface{}); ok {
										if subPropMap["type"] == "object" {
											subTypeName := title.String(subPropName)
											if subProps, ok := subPropMap["properties"].(map[string]interface{}); ok {
												goCode.WriteString(fmt.Sprintf("type %s struct {\n", subTypeName))
												for fieldName, fieldSchema := range subProps {
													fieldMap := fieldSchema.(map[string]interface{})
													fieldType := getFieldType(fieldMap)
													goFieldName := sanitizeFieldName(fieldName)
													omitempty := ""
													if required, ok := subPropMap["required"].([]interface{}); ok {
														isRequired := false
														for _, req := range required {
															if reqStr, ok := req.(string); ok && reqStr == fieldName {
																isRequired = true
																break
															}
														}
														if !isRequired {
															omitempty = ",omitempty"
														}
													}
													goCode.WriteString(fmt.Sprintf("\t%s %s `json:\"%s%s\"`\n", goFieldName, fieldType, fieldName, omitempty))
												}
												goCode.WriteString("}\n\n")
											}
										}
									}
								}

								// generate the main nested type
								goCode.WriteString(fmt.Sprintf("type %s struct {\n", nestedTypeName))
								for fieldName, fieldSchema := range nestedProps {
									fieldMap := fieldSchema.(map[string]interface{})
									var fieldType string
									if fieldMap["type"] == "object" {
										fieldType = title.String(fieldName)
									} else if fieldMap["type"] == "array" {
										if items, ok := fieldMap["items"].(map[string]interface{}); ok {
											if items["type"] == "object" {
												fieldType = "[]" + title.String(fieldName) + "Item"
											} else {
												fieldType = "[]" + getFieldType(items)
											}
										}
									} else {
										fieldType = getFieldType(fieldMap)
									}
									goFieldName := sanitizeFieldName(fieldName)
									omitempty := ""
									if required, ok := propMap["required"].([]interface{}); ok {
										isRequired := false
										for _, req := range required {
											if reqStr, ok := req.(string); ok && reqStr == fieldName {
												isRequired = true
												break
											}
										}
										if !isRequired {
											omitempty = ",omitempty"
										}
									}
									goCode.WriteString(fmt.Sprintf("\t%s %s `json:\"%s%s\"`\n", goFieldName, fieldType, fieldName, omitempty))
								}
								goCode.WriteString("}\n\n")
							}
						}
					}
				}
			}
		}
	}

	// generate predicate type
	goCode.WriteString(fmt.Sprintf("type %sPredicate struct {\n", typeName))
	if props, ok := schema["properties"].(map[string]interface{}); ok {
		if predicate, ok := props["predicate"].(map[string]interface{}); ok {
			if predicateProps, ok := predicate["properties"].(map[string]interface{}); ok {
				for propName, propSchema := range predicateProps {
					if propMap, ok := propSchema.(map[string]interface{}); ok {
						goFieldName := sanitizeFieldName(propName)
						if propMap["type"] == "object" {
							nestedTypeName := title.String(propName)
							goCode.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", goFieldName, nestedTypeName, propName))
						} else if propMap["type"] == "array" {
							if items, ok := propMap["items"].(map[string]interface{}); ok {
								if items["type"] == "object" {
									goCode.WriteString(fmt.Sprintf("\t%s []%sItem `json:\"%s\"`\n", goFieldName, title.String(propName), propName))
								} else {
									itemType := getFieldType(items)
									goCode.WriteString(fmt.Sprintf("\t%s []%s `json:\"%s\"`\n", goFieldName, itemType, propName))
								}
							}
						} else {
							fieldType := getFieldType(propMap)
							goCode.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", goFieldName, fieldType, propName))
						}
					}
				}
			}
		}
	}
	goCode.WriteString("}\n")

	return goCode.String(), nil
}

// generateStructFields generates the fields for a struct and returns any nested type definitions
func generateStructFields(schema map[string]interface{}, structName string) ([]string, []string, error) {
	var fields []string
	var nestedTypes []string

	properties, ok := schema["properties"].(map[string]interface{})
	if !ok {
		return fields, nestedTypes, nil
	}

	// Process fields
	for fieldName, fieldSchema := range properties {
		fieldMap, ok := fieldSchema.(map[string]interface{})
		if !ok {
			continue
		}

		goFieldName := sanitizeFieldName(fieldName)
		fieldType := getFieldType(fieldMap)

		// Handle nested objects
		if fieldType == "map[string]interface{}" {
			if _, ok := fieldMap["properties"].(map[string]interface{}); ok {
				nestedName := goFieldName
				nestedFields, moreNestedTypes, err := generateStructFields(fieldMap, nestedName)
				if err != nil {
					return nil, nil, err
				}
				if len(nestedFields) > 0 {
					nestedType := fmt.Sprintf("type %s struct {\n\t%s\n}", nestedName, strings.Join(nestedFields, "\n\t"))
					nestedTypes = append(nestedTypes, nestedType)
					nestedTypes = append(nestedTypes, moreNestedTypes...)
					fields = append(fields, fmt.Sprintf("%s %s `json:\"%s\"`", goFieldName, nestedName, fieldName))
					continue
				}
			}
		}

		// Handle arrays
		if strings.HasPrefix(fieldType, "[]") {
			if items, ok := fieldMap["items"].(map[string]interface{}); ok {
				itemType := getFieldType(items)
				if itemType == "map[string]interface{}" {
					if _, ok := items["properties"].(map[string]interface{}); ok {
						nestedName := goFieldName + "Item"
						nestedFields, moreNestedTypes, err := generateStructFields(items, nestedName)
						if err != nil {
							return nil, nil, err
						}
						if len(nestedFields) > 0 {
							nestedType := fmt.Sprintf("type %s struct {\n\t%s\n}", nestedName, strings.Join(nestedFields, "\n\t"))
							nestedTypes = append(nestedTypes, nestedType)
							nestedTypes = append(nestedTypes, moreNestedTypes...)
							fields = append(fields, fmt.Sprintf("%s []%s `json:\"%s\"`", goFieldName, nestedName, fieldName))
							continue
						}
					}
				}
				fields = append(fields, fmt.Sprintf("%s %s `json:\"%s\"`", goFieldName, fieldType, fieldName))
				continue
			}
		}

		// Handle basic types
		fields = append(fields, fmt.Sprintf("%s %s `json:\"%s\"`", goFieldName, fieldType, fieldName))
	}

	return fields, nestedTypes, nil
}

// getFieldType determines the Go type for a JSON schema type
func getFieldType(fieldMap map[string]interface{}) string {
	fieldType, ok := fieldMap["type"].(string)
	if !ok {
		return "interface{}"
	}

	switch fieldType {
	case "string":
		return "string"
	case "number":
		return "float64"
	case "integer":
		return "int"
	case "boolean":
		return "bool"
	case "array":
		if items, ok := fieldMap["items"].(map[string]interface{}); ok {
			itemType := getFieldType(items)
			return "[]" + itemType
		}
		return "[]interface{}"
	case "object":
		return "map[string]interface{}"
	default:
		return "interface{}"
	}
}

func createGitHubClient() *github.Client {
	// check for GitHub token in environment
	token := os.Getenv("GH_TOKEN")
	if token == "" {
		fmt.Println("Warning: No GH_TOKEN found, using unauthenticated client")
		return github.NewClient(nil)
	}

	return github.NewClient(nil).WithAuthToken(token)
}

func getVersion(ctx context.Context, client *github.Client) (string, error) {
	// check for version in environment
	if version := os.Getenv("POLICY_VERSION"); version != "" {
		// validate the tag exists
		_, _, err := client.Git.GetRef(ctx, owner, repo, "tags/"+version)
		if err == nil {
			return version, nil
		}
		return "", fmt.Errorf("specified version %s not found: %v", version, err)
	}

	// get latest release
	release, _, err := client.Repositories.GetLatestRelease(ctx, owner, repo)
	if err != nil {
		return "", fmt.Errorf("failed to get latest release: %v", err)
	}
	return release.GetTagName(), nil
}

// schemaFile represents a schema file to process
type schemaFile struct {
	name     string
	path     string
	typeName string
}

// requiredFields defines the required fields for each schema type
func getRequiredFields(schema map[string]interface{}) []string {
	var required []string
	if req, ok := schema["required"].([]interface{}); ok {
		for _, r := range req {
			if str, ok := r.(string); ok {
				required = append(required, str)
			}
		}
	}
	return required
}

// processSchemaFile processes a single schema file
func processSchemaFile(path string, typeName string) error {
	// read schema file
	schemaBytes, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read schema file %s: %v", path, err)
	}

	// parse schema
	var schema map[string]interface{}
	if err := json.Unmarshal(schemaBytes, &schema); err != nil {
		return fmt.Errorf("failed to parse schema file %s: %v", path, err)
	}

	// validate schema
	if err := validateSchema(schema); err != nil {
		return fmt.Errorf("invalid schema file %s: %v", path, err)
	}

	// generate go code
	code, err := generateSchema(schema, typeName)
	if err != nil {
		return fmt.Errorf("failed to generate struct fields for %s: %v", path, err)
	}

	// write go file with 0600 permissions
	goFile := filepath.Join(targetDir, strings.ToLower(typeName)+".go")
	if err := os.WriteFile(goFile, []byte(code), 0600); err != nil {
		return fmt.Errorf("failed to write go file %s: %v", goFile, err)
	}

	// write json schema file for reference with 0600 permissions
	jsonFile := filepath.Join(targetDir, strings.ToLower(typeName)+".schema.json")
	if err := os.WriteFile(jsonFile, schemaBytes, 0600); err != nil {
		return fmt.Errorf("failed to write schema file %s: %v", jsonFile, err)
	}

	fmt.Printf("generated %s and %s\n", goFile, jsonFile)
	return nil
}

func main() {
	// create target directory if it doesn't exist
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "failed to create target directory: %v\n", err)
		os.Exit(1)
	}

	// create github client
	client := createGitHubClient()

	// get version to use
	ctx := context.Background()
	version, err := getVersion(ctx, client)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to get version: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("using policy version: %s\n", version)

	// write common types first with 0600 permissions
	commonTypesFile := filepath.Join(targetDir, "common.go")
	if err := os.WriteFile(commonTypesFile, []byte(commonStructs), 0600); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write common types file: %v\n", err)
		os.Exit(1)
	}

	// define the schemas we want to process
	schemas := []struct {
		path     string
		typeName string
		outFile  string
	}{
		{
			path:     schemasPath + "metadata-schema.json",
			typeName: "Metadata",
			outFile:  "metadata.go",
		},
		{
			path:     schemasPath + "dependency-vulnerability-schema.json",
			typeName: "DependencyScan",
			outFile:  "dependencyscan.go",
		},
	}

	// process each schema
	for _, s := range schemas {
		content, _, _, err := client.Repositories.GetContents(ctx, owner, repo, s.path, &github.RepositoryContentGetOptions{
			Ref: version,
		})
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to get schema file %s: %v\n", s.path, err)
			continue
		}

		contentStr, err := content.GetContent()
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to get content for schema file %s: %v\n", s.path, err)
			continue
		}

		// write schema to temp file with 0600 permissions
		tempFile := filepath.Join(targetDir, filepath.Base(s.path))
		if err := os.WriteFile(tempFile, []byte(contentStr), 0600); err != nil {
			fmt.Fprintf(os.Stderr, "failed to write temp schema file %s: %v\n", tempFile, err)
			continue
		}

		// process schema file
		if err := processSchemaFile(tempFile, s.typeName); err != nil {
			fmt.Fprintf(os.Stderr, "failed to process schema file %s: %v\n", tempFile, err)
			continue
		}

		// cleanup temp file
		os.Remove(tempFile)
	}
}
